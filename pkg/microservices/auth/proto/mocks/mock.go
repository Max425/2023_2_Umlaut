// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/microservices/auth/proto/auth_grpc.pb.go

// Package mock_proto is a generated GoMock package.
package mock_proto

import (
	context "context"
	reflect "reflect"

	proto "github.com/go-park-mail-ru/2023_2_Umlaut/pkg/microservices/auth/proto"
	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockAuthorizationClient is a mock of AuthorizationClient interface.
type MockAuthorizationClient struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizationClientMockRecorder
}

// MockAuthorizationClientMockRecorder is the mock recorder for MockAuthorizationClient.
type MockAuthorizationClientMockRecorder struct {
	mock *MockAuthorizationClient
}

// NewMockAuthorizationClient creates a new mock instance.
func NewMockAuthorizationClient(ctrl *gomock.Controller) *MockAuthorizationClient {
	mock := &MockAuthorizationClient{ctrl: ctrl}
	mock.recorder = &MockAuthorizationClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthorizationClient) EXPECT() *MockAuthorizationClientMockRecorder {
	return m.recorder
}

// LogInAdmin mocks base method.
func (m *MockAuthorizationClient) LogInAdmin(ctx context.Context, in *proto.SignInInput, opts ...grpc.CallOption) (*proto.Cookie, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LogInAdmin", varargs...)
	ret0, _ := ret[0].(*proto.Cookie)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LogInAdmin indicates an expected call of LogInAdmin.
func (mr *MockAuthorizationClientMockRecorder) LogInAdmin(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogInAdmin", reflect.TypeOf((*MockAuthorizationClient)(nil).LogInAdmin), varargs...)
}

// LogOut mocks base method.
func (m *MockAuthorizationClient) LogOut(ctx context.Context, in *proto.Cookie, opts ...grpc.CallOption) (*proto.Empty, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LogOut", varargs...)
	ret0, _ := ret[0].(*proto.Empty)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LogOut indicates an expected call of LogOut.
func (mr *MockAuthorizationClientMockRecorder) LogOut(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogOut", reflect.TypeOf((*MockAuthorizationClient)(nil).LogOut), varargs...)
}

// SignIn mocks base method.
func (m *MockAuthorizationClient) SignIn(ctx context.Context, in *proto.SignInInput, opts ...grpc.CallOption) (*proto.Cookie, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SignIn", varargs...)
	ret0, _ := ret[0].(*proto.Cookie)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SignIn indicates an expected call of SignIn.
func (mr *MockAuthorizationClientMockRecorder) SignIn(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignIn", reflect.TypeOf((*MockAuthorizationClient)(nil).SignIn), varargs...)
}

// SignUp mocks base method.
func (m *MockAuthorizationClient) SignUp(ctx context.Context, in *proto.SignUpInput, opts ...grpc.CallOption) (*proto.UserId, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SignUp", varargs...)
	ret0, _ := ret[0].(*proto.UserId)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SignUp indicates an expected call of SignUp.
func (mr *MockAuthorizationClientMockRecorder) SignUp(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignUp", reflect.TypeOf((*MockAuthorizationClient)(nil).SignUp), varargs...)
}

// MockAuthorizationServer is a mock of AuthorizationServer interface.
type MockAuthorizationServer struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizationServerMockRecorder
}

// MockAuthorizationServerMockRecorder is the mock recorder for MockAuthorizationServer.
type MockAuthorizationServerMockRecorder struct {
	mock *MockAuthorizationServer
}

// NewMockAuthorizationServer creates a new mock instance.
func NewMockAuthorizationServer(ctrl *gomock.Controller) *MockAuthorizationServer {
	mock := &MockAuthorizationServer{ctrl: ctrl}
	mock.recorder = &MockAuthorizationServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthorizationServer) EXPECT() *MockAuthorizationServerMockRecorder {
	return m.recorder
}

// LogInAdmin mocks base method.
func (m *MockAuthorizationServer) LogInAdmin(arg0 context.Context, arg1 *proto.SignInInput) (*proto.Cookie, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LogInAdmin", arg0, arg1)
	ret0, _ := ret[0].(*proto.Cookie)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LogInAdmin indicates an expected call of LogInAdmin.
func (mr *MockAuthorizationServerMockRecorder) LogInAdmin(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogInAdmin", reflect.TypeOf((*MockAuthorizationServer)(nil).LogInAdmin), arg0, arg1)
}

// LogOut mocks base method.
func (m *MockAuthorizationServer) LogOut(arg0 context.Context, arg1 *proto.Cookie) (*proto.Empty, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LogOut", arg0, arg1)
	ret0, _ := ret[0].(*proto.Empty)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LogOut indicates an expected call of LogOut.
func (mr *MockAuthorizationServerMockRecorder) LogOut(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogOut", reflect.TypeOf((*MockAuthorizationServer)(nil).LogOut), arg0, arg1)
}

// SignIn mocks base method.
func (m *MockAuthorizationServer) SignIn(arg0 context.Context, arg1 *proto.SignInInput) (*proto.Cookie, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignIn", arg0, arg1)
	ret0, _ := ret[0].(*proto.Cookie)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SignIn indicates an expected call of SignIn.
func (mr *MockAuthorizationServerMockRecorder) SignIn(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignIn", reflect.TypeOf((*MockAuthorizationServer)(nil).SignIn), arg0, arg1)
}

// SignUp mocks base method.
func (m *MockAuthorizationServer) SignUp(arg0 context.Context, arg1 *proto.SignUpInput) (*proto.UserId, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignUp", arg0, arg1)
	ret0, _ := ret[0].(*proto.UserId)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SignUp indicates an expected call of SignUp.
func (mr *MockAuthorizationServerMockRecorder) SignUp(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignUp", reflect.TypeOf((*MockAuthorizationServer)(nil).SignUp), arg0, arg1)
}

// mustEmbedUnimplementedAuthorizationServer mocks base method.
func (m *MockAuthorizationServer) mustEmbedUnimplementedAuthorizationServer() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "mustEmbedUnimplementedAuthorizationServer")
}

// mustEmbedUnimplementedAuthorizationServer indicates an expected call of mustEmbedUnimplementedAuthorizationServer.
func (mr *MockAuthorizationServerMockRecorder) mustEmbedUnimplementedAuthorizationServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedAuthorizationServer", reflect.TypeOf((*MockAuthorizationServer)(nil).mustEmbedUnimplementedAuthorizationServer))
}

// MockUnsafeAuthorizationServer is a mock of UnsafeAuthorizationServer interface.
type MockUnsafeAuthorizationServer struct {
	ctrl     *gomock.Controller
	recorder *MockUnsafeAuthorizationServerMockRecorder
}

// MockUnsafeAuthorizationServerMockRecorder is the mock recorder for MockUnsafeAuthorizationServer.
type MockUnsafeAuthorizationServerMockRecorder struct {
	mock *MockUnsafeAuthorizationServer
}

// NewMockUnsafeAuthorizationServer creates a new mock instance.
func NewMockUnsafeAuthorizationServer(ctrl *gomock.Controller) *MockUnsafeAuthorizationServer {
	mock := &MockUnsafeAuthorizationServer{ctrl: ctrl}
	mock.recorder = &MockUnsafeAuthorizationServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeAuthorizationServer) EXPECT() *MockUnsafeAuthorizationServerMockRecorder {
	return m.recorder
}

// mustEmbedUnimplementedAuthorizationServer mocks base method.
func (m *MockUnsafeAuthorizationServer) mustEmbedUnimplementedAuthorizationServer() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "mustEmbedUnimplementedAuthorizationServer")
}

// mustEmbedUnimplementedAuthorizationServer indicates an expected call of mustEmbedUnimplementedAuthorizationServer.
func (mr *MockUnsafeAuthorizationServerMockRecorder) mustEmbedUnimplementedAuthorizationServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedAuthorizationServer", reflect.TypeOf((*MockUnsafeAuthorizationServer)(nil).mustEmbedUnimplementedAuthorizationServer))
}
